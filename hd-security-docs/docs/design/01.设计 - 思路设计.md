---
title: 思路设计
date: 2025-01-16 22:58:15
permalink: /design/login/
---

## 前言

作为设计思路的开篇文档，本文档主要讲 **登录认证** 的设计。

**登录认证** 是认证类框架的主要核心、基座，是最重要的一环，任何的功能、特性都需要围绕 **登录认证** 来展开，如果你没有在系统登录过，那么无法查看系统的主要页面，体验系统的核心功能。同时它也是系统安全的保证，阻挡外界恶意的攻击。

想要实现登录功能，许多人有这样一个思路：

- 前端调用登录接口，将用户名和密码（加密）通过 API 传到后端
- 后端将持有的用户名和密码去数据库进行匹配，如果两者同时存在，则认为登录成功
- 登陆成功后，后端将登录信息（用户名、权限、性别等）存到缓存（内存、Session、Redis 等）里，并返回前端一个凭证（Cookie、Token、JWT），该凭证也会存到缓存里
- 前端将凭证（Token）存到浏览器缓存里（localStorage、sessionStorage、Cookie 等），在请求后端的资源时候，同时携带凭证过去（Param、Body、Header、Cookie）
- 后端在接收请求的第一步，就是校验凭证是否存在缓存里，存在则校验是否有权限访问，如果都通过认证则往下执行逻辑，不存在则直接告诉前端需要登录

这是一个通用、流行的思路，基本上所有的后端、框架的实现都离不开这个思路，只是拓展方向的深度不一样。

作为代码开发者，我们都离不开 **封装** 这一行为，无论是工作上的 Code Review，还是阅读框架源码，我们都经常看到常用的功能都会给予一个方法来封装，以便达到通用性，比如为了减少编写「判断字符串是否为空」的重复性代码，我们会将其进行封装：

```java
public static boolean isEmpty(Character str) {
    return str != null && !"".equals(str); // [!code focus]
}

// 使用
public static void say(String keyword) {
    if(isEmpty(keyword)) {
        rteurn;
    }
}
```

回到登录认证，当你为一个新的项目开发登录认证功能时，你第一步想到的也许是：翻开之前某个项目写的登录认证代码进行参考，甚至如果业务类似，你会把代码 copy 过来进行些许的修改。

当你进行 3 次以上的这样重复性工作时，你应该有一个意识，那就是 **封装**。

所以针对登录认证，我们完全可以使用开发过这方面的经验来 **封装** 一个登录认证框架，比如我叫做 `Hd Security`。

## 账号登录

### 开始

登录认证首先离不开登录，我们可以定义一个方法 `login`，接收一个登录的标识 `loginId`：

```java
public class HdLoginHelper {
    /**
     * 执行登录操作
     */
    public String login(Object loginId) {
        // do login
        
        // 返回凭证
    }
}
```

因为我们封装的是一个通用框架，那么希望尽量不要数据库的交互，于是拿用户名和密码去数据库匹对的功能，完全在项目里实现：

```java
public class LoginService {
    public void doLogin(String username, String password) {
        boolean isMatch = connectDb().match(username, password);
        
        if(isMatch) {
            new HdLoginHelper().login(loginId); // [!code focus]
        }
    }
}
```

初期的设计里，框架仅仅存储认证成功后的登录信息，并不会做验证功能。

针对 `HdLoginHelper` 的 `login` 登录 API，我们可以继续拓展：

- 登录信息存在框架里需要过期时间，否则系统的资源不安全，同时内存也会累计变多
- 支持不同设备的登录，比如 PC、App、iPad 等
- 支持记住我功能，在登录后离开的一段时间，回来时依然有效

于是我们拓展 API：

```java
public class HdLoginHelper {
    /**
     * 执行登录操作
     */
    public String login(Object loginId) {
        // 执行逻辑，最后返回凭证
    }
    
    /**
     * 执行登录操作，并指定设备类型
     */
    public String login(Object loginId, String device) {
        // 执行逻辑，最后返回凭证
    }
    
    /**
     * 执行登录操作，并指定过期时间
     */
    public String login(Object loginId, long tokenExpireTime) {
        // 执行逻辑，最后返回凭证
    }
    
    /**
     * 执行登录操作，并指定是否记住我功能
     */
    public String login(Object loginId, boolean rememberMe) {
        // 执行逻辑，最后返回凭证
    }
}
```

但是我即想传入设备，也想传入过期时间，那么怎么办？

第一个方法就是拓展 API 的参数，第二个方法就是封装一个实体类：

```java
public class HdLoginModel {
    /**
     * 登录 ID
     */
    private Object loginId;
    /**
     * 设备名称
     */
    private String device = DefaultConstant.DEFAULT_LOGIN_DEVICE;
    /**
     * 是否记住我（记住我即创建持久 Cookie：临时 Cookie 在浏览器关闭时会自动删除，持久 Cookie 在重新打开后依然存在）
     */
    private Boolean rememberMe = true;
    /**
     * Token 过期时间（单位：秒）,如未指定，则使用全局配置的 timeout 值
     */
    private Long tokenExpireTime;
    
    // setter getter
}
```

然后进一步拓展 API

```java {33-35}
public class HdLoginHelper {
    /**
     * 执行登录操作
     */
    public String login(Object loginId) {
        return login(new HdLoginModel().setLoginId(loginId)) 
    }
    
    /**
     * 执行登录操作，并指定设备类型
     */
    public String login(Object loginId, String device) {
        return login(new HdLoginModel().setLoginId(loginId).setDevice(device)) 
    }
    
    /**
     * 执行登录操作，并指定过期时间
     */
    public String login(Object loginId, long tokenExpireTime) {
        return login(new HdLoginModel().setLoginId(loginId).setTokenExpireTime(tokenExpireTime))) 
    }
    
    /**
     * 执行登录操作，并指定是否记住我功能
     */
    public String login(Object loginId, boolean rememberMe) {
        return login(new HdLoginModel().setLoginId(loginId).setRememberMe(rememberMe)) 
    }
    
    /**
     * 执行登录操作
     */
    public String login(HdLoginModel loginModel) { // [!code focus]
       // 执行逻辑，最后返回凭证 // [!code focus]
    } // [!code focus]
}
```

这样就是一个有通用性的 API，我们只需要在 `login(HdLoginModel loginModel)` 方法里编写登录逻辑就可以了，当我们想要添加更多特性的时候，可以在 `HdLoginModel` 类里添加属性来支持特性。

### 深入

大家想一想登录逻辑都有哪些？

首先我们可以在登录前和登录后通知开发者：

- 我将要执行登录了，你可以在 **一个方法** 里接收我要传的参数来进行你额外的业务逻辑
- 我已经完成登录了，你可以在 **一个方法** 里接收我要传的参数来进行你额外的业务逻辑

这个方法叫做 **钩子**，当到某一个阶段的时候就会执行 **一个方法**，开发者可以实现这个方法来接收参数，并做自己额外的逻辑处理，大家在使用 Vue、Spring Boot 的时候，都会使用过钩子方法。

```java
public String login(HdLoginModel loginModel) {
    // 发布登录开始事件
    HdSecurityEventCenter.publishBeforeLogin(loginModel.getLoginId()); // [!code focus]

    // 创建凭证 token
    String token = createTokenAndSave(loginModel);

    // 发布登录结束事件
    HdSecurityEventCenter.publishAfterLogin(loginModel.getLoginId(), token, loginModel); // [!code focus]

    // 返回凭证
    return token;
}
```

具体怎么发布事件，这里就先不做阐述，可以看 [事件发布]

在发布登录开始事件后，框架需要创建一个凭证 Token，来返回给前端，存储的目的是为了前端每次调用后台接口的时候，进行判断是否登录过。

```java
public Map<String, Object> dataMap = new ConcurrentHashMap<>();
/**
* 存储数据过期时间的集合（单位: 毫秒）
*/
public Map<String, Long> expireMap = new ConcurrentHashMap<>();

public String createTokenAndSave(HdLoginModel loginModel) {
    String token = UUID.randomUUID().toString();
    
    dataMap.put(token, loginModel.getLoginId());
    dataMap.put(token, loginModel.getDevice());
    
    // 设置 Token 过期时间
    expireMap.add(token, loginModel.getTtokenExpireTime());
    
    return token;
}
```

这样我们就实现了一个简单的登录功能，上面使用的持久层为 Map，实际可以使用 Redis 存储：

```java
public class LoginService {
    public String doLogin(String username, String password) {
        boolean isMatch = connectDb().match(username, password);

        if(!isMatch) {
            return;
        }

        String token = new HdLoginHelper().login(loginId, 60);
        
        // 将 token 传到前端
        return token;
    }
}
```

### 总结

实现登录的逻辑总结如下：

- 执行 `login(loginId)` 方法
- 登录前发布通知事件
- 创建 Token 并存储
- 登录后发布通知事件
- 将 Token 返回到前端

## 账号登出

### 注销



### 顶人下线



### 踢人下线





## 账号封禁



